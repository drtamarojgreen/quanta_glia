# ðŸŒ± Module Enhancement Opportunities

## UX or CLI Improvements
- [ ] Streamline feedback or log formats
- [ ] Add verbosity toggles or progress display

## Learning & Adaptation
- [ ] Integrate new pattern recognition or behavior shaping logic
- [ ] Enable module to update itself from verified QuantaGlia knowledge

## Resilience Features
- [ ] Better handling of low-resource environments
- [ ] Soft fallback routines when encountering unknown inputs

## Interoperability
- [ ] Enable tighter scheduling control via QuantaParent
- [ ] Improve YAML or JSON config readability

## Future Roadmap
- [ ] Federated integration across machines?
- [ ] Test in embedded or containerized environments

---

# Proposed Enhancements for QuantaGlia-Pruner

## Learning & Adaptation
- [ ] **Similarity Analysis:** Use NLP techniques (e.g., doc2vec, TF-IDF) to analyze the content of READMEs and other documents to identify redundant or similar repositories.
- [ ] **Dependency Graph:** Build a dependency graph of the repositories in the knowledge base to avoid pruning repositories that are dependencies of others. This could be done by parsing `requirements.txt`, `package.json`, etc.
- [ ] **Usage-Based Pruning:** Integrate more tightly with QuantaSensa to get fine-grained data on which pieces of knowledge are being actively used, and use this as a primary factor in pruning decisions.

## Resilience Features
- [ ] **Dry Run Mode:** Add a "dry run" mode to the pruner that simulates pruning actions and logs what would have been done without actually performing any destructive operations.
- [ ] **Configurable Pruning Strategies:** Allow users to define different pruning strategies in the `config.yaml`, such as "conservative" (archive only), "aggressive" (delete aggressively), or "balanced".

## Interoperability
- [ ] **Webhook Notifications:** When a repository is pruned, send a webhook notification to a specified URL, allowing other systems to react to the change.
- [ ] **Human-in-the-Loop:** For borderline cases, instead of making an autonomous decision, the pruner could flag the repository for human review and wait for approval before taking action.

---

# Proposed Enhancements for QuantaGlia-Harvester

## Codebase & Dependencies
- [ ] **Replace Custom YAML Parser:** Replace the fragile, custom `load_config` function with a standard library like `PyYAML` or `ruamel.yaml` to improve robustness and support for more complex configuration structures.
- [ ] **Use a Git Library:** Abstract away `subprocess` calls to the `git` command-line tool by using a dedicated Python library like `GitPython`. This will improve error handling, platform compatibility, and code clarity.

## Configuration
- [ ] **Selective File Extraction:** Add a configuration option to limit the file search to specific directories (e.g., `["/", "/docs"]`) or a specific depth to avoid inefficiently scanning very large repositories.
- [ ] **Configurable Logging Verbosity:** Implement a `log_level` setting in `config.yaml` (e.g., `DEBUG`, `INFO`, `WARNING`) to allow users to control the verbosity of the `quantaglia.log` file.

## Functionality
- [ ] **Robust Local Path Handling:** Improve the script to reliably handle local filesystem paths (`../my-repo`) in addition to remote Git URLs, making it more flexible for local development and testing.
- [ ] **File Content Summarization:** Instead of storing the entire raw content of discovered files, add an option to process and store a summary (e.g., the first N lines, or a summary generated by an NLP library). This would make the "knowledge base" more distilled.

---

# Comprehensive Feature Roadmap

## Core Harvester Functionality
- [ ] **Multi-VCS Support:** Extend cloning capabilities to support other Version Control Systems like Mercurial or SVN.
- [ ] **Git History Analysis:** Extract metadata from git history, such as commit frequency, author activity, and file churn, to better assess repository health.
- [ ] **Structured File Parsing:** Natively parse structured files like `package.json`, `pom.xml`, or `requirements.txt` to build a dependency graph of the knowledge base.
- [ ] **Binary File Handling:** Implement metadata extraction for non-text files (e.g., EXIF data from images, properties from PDFs) instead of just ignoring them.
- [ ] **Incremental Harvesting:** Develop a mechanism to re-scan only the changed files within a repository since the last harvest, improving efficiency for large, active repos.

## Pruner Functionality
- [ ] **Pruning Sandbox:** Create a "sandbox" mode where pruning strategies can be tested against the knowledge base without performing any destructive actions.
- [ ] **Code Quality Pruning:** Integrate static analysis tools (e.g., `radon`, `lizard`) to enable pruning strategies based on code quality metrics like cyclomatic complexity or number of code smells.
- [ ] **Flexible Archiving Backends:** Allow configuration of different archiving destinations, such as cloud storage (S3, Azure Blob), or network drives, instead of just local deletion.
- [ ] **Community Metrics Pruning:** Factor in community activity metrics from platforms like GitHub/GitLab (e.g., stars, forks, issue response time) into pruning decisions.
- [ ] **Interactive Pruning Mode:** Add a CLI mode that prompts a human for confirmation on each pruning decision, showing a summary and a recommendation.

## System Integration & Architecture
- [ ] **Daemonization:** Re-architect the script to run as a persistent, background daemon or service for continuous operation.
- [ ] **GraphQL API:** Implement a GraphQL API for more flexible and efficient querying of the knowledge base, as an alternative or replacement for a REST API.
- [ ] **CI/CD Integration:** Provide webhooks or plugins to allow CI/CD systems (like Jenkins, GitLab CI) to trigger harvesting or pruning runs automatically after builds or deployments.
- [ ] **Federated Architecture:** Design a system for multiple QuantaGlia instances to communicate, share knowledge, and coordinate actions across a distributed network.
- [ ] **Event-Driven Communication:** Move from script-based execution to an event-driven model using a message bus (e.g., RabbitMQ, Kafka) for robust, asynchronous inter-module communication.
